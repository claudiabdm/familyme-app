"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Debug = require("debug");
const depGraphLib = require("@snyk/dep-graph");
const snyk = require("..");
const api_token_1 = require("../api-token");
const request = require("../request");
const config = require("../config");
const os = require("os");
const _ = require("lodash");
const is_ci_1 = require("../is-ci");
const analytics = require("../analytics");
const projectMetadata = require("../project-metadata");
const errors_1 = require("../errors");
const prune_1 = require("../prune");
const package_managers_1 = require("../package-managers");
const feature_flags_1 = require("../feature-flags");
const count_total_deps_in_tree_1 = require("./count-total-deps-in-tree");
const filter_out_missing_deps_1 = require("./filter-out-missing-deps");
const drop_empty_deps_1 = require("./drop-empty-deps");
const prune_dep_tree_1 = require("./prune-dep-tree");
const policy_1 = require("../policy");
const debug = Debug('snyk');
function monitor(root, meta, scannedProject, options, pluginMeta, targetFileRelativePath) {
    return __awaiter(this, void 0, void 0, function* () {
        api_token_1.apiTokenExists();
        let treeMissingDeps = [];
        const packageManager = meta.packageManager;
        analytics.add('packageManager', packageManager);
        analytics.add('isDocker', !!meta.isDocker);
        analytics.add('monitorGraph', true);
        if (package_managers_1.GRAPH_SUPPORTED_PACKAGE_MANAGERS.includes(packageManager)) {
            const monitorGraphSupportedRes = yield feature_flags_1.isFeatureFlagSupportedForOrg(_.camelCase('experimental-dep-graph'), options.org || config.org);
            if (monitorGraphSupportedRes.code === 401) {
                throw errors_1.AuthFailedError(monitorGraphSupportedRes.error, monitorGraphSupportedRes.code);
            }
            if (monitorGraphSupportedRes.ok) {
                return yield monitorGraph(root, meta, scannedProject, pluginMeta, targetFileRelativePath);
            }
            if (monitorGraphSupportedRes.userMessage) {
                debug(monitorGraphSupportedRes.userMessage);
            }
        }
        let pkg = scannedProject.depTree;
        let prePruneDepCount;
        if (meta.prune) {
            debug('prune used, counting total dependencies');
            prePruneDepCount = count_total_deps_in_tree_1.countTotalDependenciesInTree(scannedProject.depTree);
            analytics.add('prePruneDepCount', prePruneDepCount);
            debug('total dependencies: %d', prePruneDepCount);
            debug('pruning dep tree');
            pkg = yield prune_dep_tree_1.pruneTree(scannedProject.depTree, meta.packageManager);
            debug('finished pruning dep tree');
        }
        if (['npm', 'yarn'].includes(meta.packageManager)) {
            const { filteredDepTree, missingDeps } = filter_out_missing_deps_1.filterOutMissingDeps(scannedProject.depTree);
            pkg = filteredDepTree;
            treeMissingDeps = missingDeps;
        }
        const policyPath = meta['policy-path'] || root;
        const policyLocations = [policyPath]
            .concat(policy_1.pluckPolicies(pkg))
            .filter(Boolean);
        // docker doesn't have a policy as it can be run from anywhere
        if (!meta.isDocker || !policyLocations.length) {
            yield snyk.policy.create();
        }
        const policy = yield snyk.policy.load(policyLocations, { loose: true });
        const target = yield projectMetadata.getInfo(pkg, meta);
        if (target && target.branch) {
            analytics.add('targetBranch', target.branch);
        }
        pkg = drop_empty_deps_1.dropEmptyDeps(pkg);
        // TODO(kyegupov): async/await
        return new Promise((resolve, reject) => {
            request({
                body: {
                    meta: {
                        method: meta.method,
                        hostname: os.hostname(),
                        id: snyk.id || pkg.name,
                        ci: is_ci_1.isCI(),
                        pid: process.pid,
                        node: process.version,
                        master: snyk.config.isMaster,
                        name: pkg.name,
                        version: pkg.version,
                        org: config.org ? decodeURIComponent(config.org) : undefined,
                        pluginName: pluginMeta.name,
                        pluginRuntime: pluginMeta.runtime,
                        missingDeps: treeMissingDeps,
                        dockerImageId: pluginMeta.dockerImageId,
                        dockerBaseImage: pkg.docker ? pkg.docker.baseImage : undefined,
                        dockerfileLayers: pkg.docker
                            ? pkg.docker.dockerfileLayers
                            : undefined,
                        projectName: meta['project-name'],
                        prePruneDepCount,
                        monitorGraph: false,
                    },
                    policy: policy ? policy.toString() : undefined,
                    package: pkg,
                    // we take the targetFile from the plugin,
                    // because we want to send it only for specific package-managers
                    target,
                    // WARNING: be careful changing this as it affects project uniqueness
                    targetFile: pluginMeta.targetFile,
                    targetFileRelativePath,
                },
                gzip: true,
                method: 'PUT',
                headers: {
                    authorization: 'token ' + snyk.api,
                    'content-encoding': 'gzip',
                },
                url: config.API + '/monitor/' + packageManager,
                json: true,
            }, (error, res, body) => {
                if (error) {
                    return reject(error);
                }
                if (res.statusCode >= 200 && res.statusCode <= 299) {
                    resolve(body);
                }
                else {
                    let err;
                    const userMessage = body && body.userMessage;
                    if (!userMessage && res.statusCode === 504) {
                        err = new errors_1.ConnectionTimeoutError();
                    }
                    else {
                        err = new errors_1.MonitorError(res.statusCode, userMessage);
                    }
                    reject(err);
                }
            });
        });
    });
}
exports.monitor = monitor;
function monitorGraph(root, meta, scannedProject, pluginMeta, targetFileRelativePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageManager = meta.packageManager;
        analytics.add('monitorGraph', true);
        let treeMissingDeps;
        let pkg = scannedProject.depTree;
        const policyPath = meta['policy-path'] || root;
        const policyLocations = [policyPath]
            .concat(policy_1.pluckPolicies(pkg))
            .filter(Boolean);
        if (['npm', 'yarn'].includes(meta.packageManager)) {
            const { filteredDepTree, missingDeps } = filter_out_missing_deps_1.filterOutMissingDeps(pkg);
            pkg = filteredDepTree;
            treeMissingDeps = missingDeps;
        }
        const depGraph = yield depGraphLib.legacy.depTreeToGraph(pkg, packageManager);
        // docker doesn't have a policy as it can be run from anywhere
        if (!meta.isDocker || !policyLocations.length) {
            yield snyk.policy.create();
        }
        const policy = yield snyk.policy.load(policyLocations, { loose: true });
        const target = yield projectMetadata.getInfo(pkg, meta);
        if (target && target.branch) {
            analytics.add('targetBranch', target.branch);
        }
        let prunedGraph = depGraph;
        let prePruneDepCount;
        if (meta.prune) {
            debug('Trying to prune the graph');
            prePruneDepCount = prune_1.countPathsToGraphRoot(depGraph);
            debug('pre prunedPathsCount: ' + prePruneDepCount);
            prunedGraph = yield prune_1.pruneGraph(depGraph, packageManager);
        }
        return new Promise((resolve, reject) => {
            request({
                body: {
                    meta: {
                        method: meta.method,
                        hostname: os.hostname(),
                        id: snyk.id || pkg.name,
                        ci: is_ci_1.isCI(),
                        pid: process.pid,
                        node: process.version,
                        master: snyk.config.isMaster,
                        name: depGraph.rootPkg.name,
                        version: depGraph.rootPkg.version,
                        org: config.org ? decodeURIComponent(config.org) : undefined,
                        pluginName: pluginMeta.name,
                        pluginRuntime: pluginMeta.runtime,
                        dockerImageId: pluginMeta.dockerImageId,
                        dockerBaseImage: pkg.docker ? pkg.docker.baseImage : undefined,
                        dockerfileLayers: pkg.docker
                            ? pkg.docker.dockerfileLayers
                            : undefined,
                        projectName: meta['project-name'],
                        prePruneDepCount,
                        missingDeps: treeMissingDeps,
                        monitorGraph: true,
                    },
                    policy: policy ? policy.toString() : undefined,
                    depGraphJSON: prunedGraph,
                    // we take the targetFile from the plugin,
                    // because we want to send it only for specific package-managers
                    target,
                    targetFile: pluginMeta.targetFile,
                    targetFileRelativePath,
                },
                gzip: true,
                method: 'PUT',
                headers: {
                    authorization: 'token ' + snyk.api,
                    'content-encoding': 'gzip',
                },
                url: `${config.API}/monitor/${packageManager}/graph`,
                json: true,
            }, (error, res, body) => {
                if (error) {
                    return reject(error);
                }
                if (res.statusCode >= 200 && res.statusCode <= 299) {
                    resolve(body);
                }
                else {
                    let err;
                    const userMessage = body && body.userMessage;
                    if (!userMessage && res.statusCode === 504) {
                        err = new errors_1.ConnectionTimeoutError();
                    }
                    else {
                        err = new errors_1.MonitorError(res.statusCode, userMessage);
                    }
                    reject(err);
                }
            });
        });
    });
}
exports.monitorGraph = monitorGraph;
//# sourceMappingURL=index.js.map