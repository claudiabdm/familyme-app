"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const path = require("path");
const cliInterface = require("@snyk/cli-interface");
const detect_1 = require("../detect");
const get_single_plugin_result_1 = require("./get-single-plugin-result");
const convert_single_splugin_res_to_multi_custom_1 = require("./convert-single-splugin-res-to-multi-custom");
const convert_multi_plugin_res_to_multi_custom_1 = require("./convert-multi-plugin-res-to-multi-custom");
function getMultiPluginResult(root, options, targetFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        const allResults = [];
        for (const targetFile of targetFiles) {
            const optionsClone = _.cloneDeep(options);
            optionsClone.file = path.relative(root, targetFile);
            optionsClone.packageManager = detect_1.detectPackageManagerFromFile(path.basename(targetFile));
            try {
                const inspectRes = yield get_single_plugin_result_1.getSinglePluginResult(root, optionsClone, optionsClone.file);
                let resultWithScannedProjects;
                if (!cliInterface.legacyPlugin.isMultiResult(inspectRes)) {
                    resultWithScannedProjects = convert_single_splugin_res_to_multi_custom_1.convertSingleResultToMultiCustom(inspectRes, optionsClone.packageManager);
                }
                else {
                    resultWithScannedProjects = inspectRes;
                }
                const pluginResultWithCustomScannedProjects = convert_multi_plugin_res_to_multi_custom_1.convertMultiResultToMultiCustom(resultWithScannedProjects, optionsClone.packageManager, optionsClone.file);
                // annotate the package manager, project name & targetFile to be used
                // for test & monitor
                // TODO: refactor how we display meta to not have to do this
                options.projectNames = resultWithScannedProjects.scannedProjects.map((scannedProject) => scannedProject.depTree.name);
                allResults.push(...pluginResultWithCustomScannedProjects.scannedProjects);
            }
            catch (err) {
                console.log(err);
            }
        }
        return {
            plugin: {
                name: 'custom-auto-detect',
            },
            scannedProjects: allResults,
        };
    });
}
exports.getMultiPluginResult = getMultiPluginResult;
//# sourceMappingURL=get-multi-plugin-result.js.map