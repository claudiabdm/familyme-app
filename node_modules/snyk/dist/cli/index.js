#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const Debug = require("debug");
const pathLib = require("path");
// assert supported node runtime version
const runtime = require("./runtime");
// require analytics as soon as possible to start measuring execution time
const analytics = require("../lib/analytics");
const alerts = require("../lib/alerts");
const sln = require("../lib/sln");
const args_1 = require("./args");
const copy_1 = require("./copy");
const spinner = require("../lib/spinner");
const errors = require("../lib/errors/legacy-errors");
const ansiEscapes = require("ansi-escapes");
const detect_1 = require("../lib/detect");
const updater_1 = require("../lib/updater");
const errors_1 = require("../lib/errors");
const strip_ansi_1 = require("strip-ansi");
const exclude_flag_invalid_input_1 = require("../lib/errors/exclude-flag-invalid-input");
const debug = Debug('snyk');
const EXIT_CODES = {
    VULNS_FOUND: 1,
    ERROR: 2,
};
function runCommand(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield args.method(...args.options._);
        const res = analytics({
            args: args.options._,
            command: args.command,
            org: args.options.org,
        });
        if (result && !args.options.quiet) {
            if (args.options.copy) {
                copy_1.copy(result);
                console.log('Result copied to clipboard');
            }
            else {
                console.log(result);
            }
        }
        return res;
    });
}
function handleError(args, error) {
    return __awaiter(this, void 0, void 0, function* () {
        spinner.clearAll();
        let command = 'bad-command';
        let exitCode = EXIT_CODES.ERROR;
        const vulnsFound = error.code === 'VULNS';
        if (vulnsFound) {
            // this isn't a bad command, so we won't record it as such
            command = args.command;
            exitCode = EXIT_CODES.VULNS_FOUND;
        }
        if (args.options.debug && !args.options.json) {
            const output = vulnsFound ? error.message : error.stack;
            console.log(output);
        }
        else if (args.options.json) {
            console.log(strip_ansi_1.default(error.json || error.stack));
        }
        else {
            if (!args.options.quiet) {
                const result = errors.message(error);
                if (args.options.copy) {
                    copy_1.copy(result);
                    console.log('Result copied to clipboard');
                }
                else {
                    if (`${error.code}`.indexOf('AUTH_') === 0) {
                        // remove the last few lines
                        const erase = ansiEscapes.eraseLines(4);
                        process.stdout.write(erase);
                    }
                    console.log(result);
                }
            }
        }
        const analyticsError = vulnsFound
            ? {
                stack: error.jsonNoVulns,
                code: error.code,
                message: 'Vulnerabilities found',
            }
            : {
                stack: error.stack,
                code: error.code,
                message: error.message,
            };
        if (!vulnsFound && !error.stack) {
            // log errors that are not error objects
            analytics.add('error', true);
            analytics.add('command', args.command);
        }
        else {
            analytics.add('error-message', analyticsError.message);
            // Note that error.stack would also contain the error message
            // (see https://nodejs.org/api/errors.html#errors_error_stack)
            analytics.add('error', analyticsError.stack);
            analytics.add('error-code', error.code);
            analytics.add('command', args.command);
        }
        const res = analytics({
            args: args.options._,
            command,
            org: args.options.org,
        });
        return { res, exitCode };
    });
}
function checkRuntime() {
    if (!runtime.isSupported(process.versions.node)) {
        console.error(`${process.versions.node} is an unsupported nodejs ` +
            `runtime! Supported runtime range is '${runtime.supportedRange}'`);
        console.error('Please upgrade your nodejs runtime version and try again.');
        process.exit(EXIT_CODES.ERROR);
    }
}
// Throw error if user specifies package file name as part of path,
// and if user specifies multiple paths and used project-name option.
function checkPaths(args) {
    let count = 0;
    for (const path of args.options._) {
        if (typeof path === 'string' && detect_1.isPathToPackageFile(path)) {
            throw errors_1.MissingTargetFileError(path);
        }
        else if (typeof path === 'string') {
            if (++count > 1 && args.options['project-name']) {
                throw new errors_1.UnsupportedOptionCombinationError([
                    'multiple paths',
                    'project-name',
                ]);
            }
        }
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        updater_1.updateCheck();
        checkRuntime();
        const args = args_1.args(process.argv);
        let res;
        let failed = false;
        let exitCode = EXIT_CODES.ERROR;
        try {
            if (args.options.scanAllUnmanaged && args.options.file) {
                throw new errors_1.UnsupportedOptionCombinationError([
                    'file',
                    'scan-all-unmanaged',
                ]);
            }
            if (args.options['project-name'] && args.options.allProjects) {
                throw new errors_1.UnsupportedOptionCombinationError([
                    'project-name',
                    'all-projects',
                ]);
            }
            if (args.options.file && args.options.allProjects) {
                throw new errors_1.UnsupportedOptionCombinationError(['file', 'all-projects']);
            }
            if (args.options.packageManager && args.options.allProjects) {
                throw new errors_1.UnsupportedOptionCombinationError([
                    'package-manager',
                    'all-projects',
                ]);
            }
            if (args.options.docker && args.options.allProjects) {
                throw new errors_1.UnsupportedOptionCombinationError(['docker', 'all-projects']);
            }
            if (args.options.allSubProjects && args.options.allProjects) {
                throw new errors_1.UnsupportedOptionCombinationError([
                    'all-sub-projects',
                    'all-projects',
                ]);
            }
            if (args.options.exclude) {
                if (typeof args.options.exclude !== 'string') {
                    throw new errors_1.ExcludeFlagBadInputError();
                }
                if (!args.options.allProjects) {
                    throw new errors_1.OptionMissingErrorError('--exclude', '--all-projects');
                }
                if (args.options.exclude.indexOf(pathLib.sep) > -1) {
                    throw new exclude_flag_invalid_input_1.ExcludeFlagInvalidInputError();
                }
            }
            if (args.options.file &&
                typeof args.options.file === 'string' &&
                args.options.file.match(/\.sln$/)) {
                if (args.options['project-name']) {
                    throw new errors_1.UnsupportedOptionCombinationError([
                        'file=*.sln',
                        'project-name',
                    ]);
                }
                sln.updateArgs(args);
            }
            else if (typeof args.options.file === 'boolean') {
                throw new errors_1.FileFlagBadInputError();
            }
            checkPaths(args);
            res = yield runCommand(args);
        }
        catch (error) {
            failed = true;
            const response = yield handleError(args, error);
            res = response.res;
            exitCode = response.exitCode;
        }
        if (!args.options.json) {
            console.log(alerts.displayAlerts());
        }
        if (!process.env.TAP && failed) {
            debug('Exit code: ' + exitCode);
            process.exitCode = exitCode;
        }
        return res;
    });
}
const cli = main().catch((e) => {
    console.error('Something unexpected went wrong: ', e.stack);
    console.error('Exit code: ' + EXIT_CODES.ERROR);
    process.exit(EXIT_CODES.ERROR);
});
if (module.parent) {
    // eslint-disable-next-line id-blacklist
    module.exports = cli;
}
//# sourceMappingURL=index.js.map