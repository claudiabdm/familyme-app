"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _ = require("lodash");
const pMap = require("p-map");
const _1 = require("./");
const get_node_runtime_version_1 = require("../get-node-runtime-version");
const set_immediate_promise_1 = require("../set-immediate-promise");
const errors_1 = require("../errors");
const EVENT_PROCESSING_CONCURRENCY = 5;
class YarnLockParser {
    constructor() {
        this.eventLoopSpinRate = 20;
        // @yarnpkg/lockfile doesn't work with Node.js < 6 and crashes just after
        // the import, so it has to be required conditionally
        // more details at https://github.com/yarnpkg/yarn/issues/6304
        if (get_node_runtime_version_1.default() < 6) {
            throw new errors_1.UnsupportedRuntimeError('yarn.lock parsing is supported for ' +
                'Node.js v6 and higher.');
        }
        this.yarnLockfileParser = require('@yarnpkg/lockfile');
        // Number of dependencies including root one.
        this.treeSize = 1;
    }
    parseLockFile(lockFileContents) {
        try {
            const yarnLock = this.yarnLockfileParser.parse(lockFileContents);
            yarnLock.dependencies = yarnLock.object;
            yarnLock.type = _1.LockfileType.yarn;
            return yarnLock;
        }
        catch (e) {
            throw new errors_1.InvalidUserInputError('yarn.lock parsing failed with an ' +
                `error: ${e.message}`);
        }
    }
    getDependencyTree(manifestFile, lockfile, includeDev = false, strict = true) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (lockfile.type !== _1.LockfileType.yarn) {
                throw new errors_1.InvalidUserInputError('Unsupported lockfile provided. ' +
                    'Please provide `package-lock.json`.');
            }
            const yarnLock = lockfile;
            const depTree = {
                dependencies: {},
                hasDevDependencies: !_.isEmpty(manifestFile.devDependencies),
                name: manifestFile.name,
                size: 1,
                version: manifestFile.version || '',
            };
            const nodeVersion = _.get(manifestFile, 'engines.node');
            if (nodeVersion) {
                _.set(depTree, 'meta.nodeVersion', nodeVersion);
            }
            const topLevelDeps = _1.getTopLevelDeps(manifestFile, includeDev);
            // asked to process empty deps
            if (_.isEmpty(manifestFile.dependencies) && !includeDev) {
                return depTree;
            }
            yield pMap(topLevelDeps, (dep) => this.resolveDep(dep, depTree, yarnLock, strict), { concurrency: EVENT_PROCESSING_CONCURRENCY });
            depTree.size = this.treeSize;
            return depTree;
        });
    }
    buildSubTree(lockFile, tree, strict) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const queue = [{ path: [], tree }];
            while (queue.length > 0) {
                const queueItem = queue.pop();
                const depKey = `${queueItem.tree.name}@${queueItem.tree.version}`;
                const dependency = lockFile.object[depKey];
                if (!dependency) {
                    if (strict) {
                        throw new errors_1.OutOfSyncError(queueItem.tree.name, 'yarn');
                    }
                    if (!queueItem.tree.labels) {
                        queueItem.tree.labels = {};
                    }
                    queueItem.tree.labels.missingLockFileEntry = 'true';
                    continue;
                }
                // Overwrite version pattern with exact version.
                queueItem.tree.version = dependency.version;
                if (queueItem.path.indexOf(depKey) >= 0) {
                    if (!queueItem.tree.labels) {
                        queueItem.tree.labels = {};
                    }
                    queueItem.tree.labels.pruned = 'cyclic';
                    continue;
                }
                const subDependencies = _.entries(Object.assign({}, dependency.dependencies, dependency.optionalDependencies));
                for (const [subName, subVersion] of subDependencies) {
                    const subDependency = {
                        labels: {
                            scope: tree.labels.scope,
                        },
                        name: subName,
                        version: subVersion,
                    };
                    if (!queueItem.tree.dependencies) {
                        queueItem.tree.dependencies = {};
                    }
                    queueItem.tree.dependencies[subName] = subDependency;
                    queue.push({
                        path: [...queueItem.path, depKey],
                        tree: subDependency,
                    });
                    this.treeSize++;
                    if (this.treeSize % this.eventLoopSpinRate === 0) {
                        // Spin event loop every X dependencies.
                        yield set_immediate_promise_1.setImmediatePromise();
                    }
                }
            }
            return tree;
        });
    }
    resolveDep(dep, depTree, yarnLock, strict) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (/^file:/.test(dep.version)) {
                depTree.dependencies[dep.name] = _1.createDepTreeDepFromDep(dep);
            }
            else {
                depTree.dependencies[dep.name] = yield this.buildSubTree(yarnLock, _1.createDepTreeDepFromDep(dep), strict);
            }
            this.treeSize++;
            if (this.treeSize % this.eventLoopSpinRate === 0) {
                // Spin event loop every X dependencies.
                yield set_immediate_promise_1.setImmediatePromise();
            }
        });
    }
}
exports.YarnLockParser = YarnLockParser;
//# sourceMappingURL=yarn-lock-parse.js.map