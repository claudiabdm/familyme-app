"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const parseXML = require("xml2js");
const _ = require("lodash");
const errors_1 = require("../errors");
var DepType;
(function (DepType) {
    DepType["prod"] = "prod";
    DepType["dev"] = "dev";
})(DepType = exports.DepType || (exports.DepType = {}));
var ProjectJsonDepType;
(function (ProjectJsonDepType) {
    ProjectJsonDepType["build"] = "build";
    ProjectJsonDepType["project"] = "project";
    ProjectJsonDepType["platform"] = "platform";
    ProjectJsonDepType["default"] = "default";
})(ProjectJsonDepType = exports.ProjectJsonDepType || (exports.ProjectJsonDepType = {}));
function getDependencyTreeFromProjectJson(manifestFile, includeDev = false) {
    const depTree = {
        dependencies: {},
        hasDevDependencies: false,
        name: '',
        version: '',
    };
    for (const depName in manifestFile.dependencies) {
        if (!manifestFile.dependencies.hasOwnProperty(depName)) {
            continue;
        }
        const depValue = manifestFile.dependencies[depName];
        const version = depValue.version || depValue;
        const isDev = depValue.type === 'build';
        depTree.hasDevDependencies = depTree.hasDevDependencies || isDev;
        if (isDev && !includeDev) {
            continue;
        }
        depTree.dependencies[depName] = buildSubTreeFromProjectJson(depName, version, isDev);
    }
    return depTree;
}
exports.getDependencyTreeFromProjectJson = getDependencyTreeFromProjectJson;
function buildSubTreeFromProjectJson(name, version, isDev) {
    const depSubTree = {
        depType: isDev ? DepType.dev : DepType.prod,
        dependencies: {},
        name,
        version,
    };
    return depSubTree;
}
function getDependencyTreeFromPackagesConfig(manifestFile, includeDev = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const depTree = {
            dependencies: {},
            hasDevDependencies: false,
            name: '',
            version: '',
        };
        const packageList = _.get(manifestFile, 'packages.package', []);
        for (const dep of packageList) {
            const depName = dep.$.id;
            const isDev = !!dep.$.developmentDependency;
            depTree.hasDevDependencies = depTree.hasDevDependencies || isDev;
            if (isDev && !includeDev) {
                continue;
            }
            depTree.dependencies[depName] = buildSubTreeFromPackagesConfig(dep, isDev);
        }
        return depTree;
    });
}
exports.getDependencyTreeFromPackagesConfig = getDependencyTreeFromPackagesConfig;
function buildSubTreeFromPackagesConfig(dep, isDev) {
    const depSubTree = {
        depType: isDev ? DepType.dev : DepType.prod,
        dependencies: {},
        name: dep.$.id,
        version: dep.$.version,
    };
    if (dep.$.targetFramework) {
        depSubTree.targetFrameworks = [dep.$.targetFramework];
    }
    return depSubTree;
}
function getDependencyTreeFromProjectFile(manifestFile, includeDev = false, propsMap = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const nameProperty = _.get(manifestFile, 'Project.PropertyGroup', [])
            .find((propertyGroup) => {
            return _.has(propertyGroup, 'PackageId')
                || _.has(propertyGroup, 'AssemblyName');
        }) || {};
        const name = (nameProperty.PackageId && nameProperty.PackageId[0])
            || (nameProperty.AssemblyName && nameProperty.AssemblyName[0])
            || '';
        const packageReferenceDeps = yield getDependenciesFromPackageReference(manifestFile, includeDev, propsMap);
        const referenceIncludeDeps = yield getDependenciesFromReferenceInclude(manifestFile, includeDev, propsMap);
        // order matters, the order deps are parsed in needs to be preserved and first seen kept
        // so applying the packageReferenceDeps last to override the second parsed
        const depTree = {
            dependencies: Object.assign(Object.assign({}, referenceIncludeDeps.dependencies), packageReferenceDeps.dependencies),
            hasDevDependencies: packageReferenceDeps.hasDevDependencies || referenceIncludeDeps.hasDevDependencies,
            name,
            version: '',
        };
        if (packageReferenceDeps.dependenciesWithUnknownVersions) {
            depTree.dependenciesWithUnknownVersions = packageReferenceDeps.dependenciesWithUnknownVersions;
        }
        if (referenceIncludeDeps.dependenciesWithUnknownVersions) {
            depTree.dependenciesWithUnknownVersions = referenceIncludeDeps.dependenciesWithUnknownVersions;
        }
        return depTree;
    });
}
exports.getDependencyTreeFromProjectFile = getDependencyTreeFromProjectFile;
function getDependenciesFromPackageReference(manifestFile, includeDev = false, propsMap) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let dependenciesResult = {
            dependencies: {},
            hasDevDependencies: false,
        };
        const packageGroups = _.get(manifestFile, 'Project.ItemGroup', [])
            .filter((itemGroup) => _.has(itemGroup, 'PackageReference'));
        if (!packageGroups.length) {
            return dependenciesResult;
        }
        for (const packageList of packageGroups) {
            dependenciesResult = processItemGroupForPackageReference(packageList, manifestFile, includeDev, dependenciesResult, propsMap);
        }
        return dependenciesResult;
    });
}
function processItemGroupForPackageReference(packageList, manifestFile, includeDev, dependenciesResult, propsMap) {
    const targetFrameworks = _.get(packageList, '$.Condition', false) ?
        getConditionalFrameworks(packageList.$.Condition) : [];
    for (const dep of packageList.PackageReference) {
        const depName = dep.$.Include;
        if (!depName) {
            // PackageReference Update is not yet supported
            continue;
        }
        const isDev = !!dep.$.developmentDependency;
        dependenciesResult.hasDevDependencies = dependenciesResult.hasDevDependencies || isDev;
        if (isDev && !includeDev) {
            continue;
        }
        const subDep = buildSubTreeFromPackageReference(dep, isDev, manifestFile, targetFrameworks, propsMap);
        if (subDep.withoutVersion) {
            dependenciesResult.dependenciesWithUnknownVersions = dependenciesResult.dependenciesWithUnknownVersions || [];
            dependenciesResult.dependenciesWithUnknownVersions.push(subDep.name);
        }
        else {
            dependenciesResult.dependencies[depName] = subDep;
        }
    }
    return dependenciesResult;
}
// TODO: almost same as getDependenciesFromPackageReference
function getDependenciesFromReferenceInclude(manifestFile, includeDev = false, propsMap) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let referenceIncludeResult = {
            dependencies: {},
            hasDevDependencies: false,
        };
        const referenceIncludeList = _.get(manifestFile, 'Project.ItemGroup', [])
            .find((itemGroup) => _.has(itemGroup, 'Reference'));
        if (!referenceIncludeList) {
            return referenceIncludeResult;
        }
        referenceIncludeResult =
            processItemGroupForReferenceInclude(referenceIncludeList, manifestFile, includeDev, referenceIncludeResult, propsMap);
        return referenceIncludeResult;
    });
}
function processItemGroupForReferenceInclude(packageList, manifestFile, includeDev, dependenciesResult, propsMap) {
    const targetFrameworks = _.get(packageList, '$.Condition', false) ?
        getConditionalFrameworks(packageList.$.Condition) : [];
    for (const item of packageList.Reference) {
        const propertiesList = item.$.Include.split(',').map((i) => i.trim());
        const [depName, ...depInfoArray] = propertiesList;
        const depInfo = {};
        if (!depName) {
            continue;
        }
        // TODO: identify dev deps @lili
        const isDev = false;
        dependenciesResult.hasDevDependencies = dependenciesResult.hasDevDependencies || isDev;
        if (isDev && !includeDev) {
            continue;
        }
        for (const itemValue of depInfoArray) {
            const propertyValuePair = itemValue.split('=');
            depInfo[propertyValuePair[0]] = propertyValuePair[1];
        }
        depInfo.name = depName;
        const subDep = buildSubTreeFromReferenceInclude(depInfo, isDev, manifestFile, targetFrameworks, propsMap);
        if (subDep.withoutVersion) {
            dependenciesResult.dependenciesWithUnknownVersions = dependenciesResult.dependenciesWithUnknownVersions || [];
            dependenciesResult.dependenciesWithUnknownVersions.push(subDep.name);
        }
        else {
            dependenciesResult.dependencies[depName] = subDep;
        }
    }
    return dependenciesResult;
}
function buildSubTreeFromReferenceInclude(dep, isDev, manifestFile, targetFrameworks, propsMap) {
    const version = extractDependencyVersion(dep, manifestFile, propsMap) || '';
    if (!_.isEmpty(version)) {
        const depSubTree = {
            depType: isDev ? DepType.dev : DepType.prod,
            dependencies: {},
            name: dep.name,
            // Version could be in attributes or as child node.
            version,
        };
        if (targetFrameworks.length) {
            depSubTree.targetFrameworks = targetFrameworks;
        }
        return depSubTree;
    }
    else {
        return { name: dep.name, withoutVersion: true };
    }
}
function buildSubTreeFromPackageReference(dep, isDev, manifestFile, targetFrameworks, propsMap) {
    const version = extractDependencyVersion(dep, manifestFile, propsMap) || '';
    if (!_.isEmpty(version)) {
        const depSubTree = {
            depType: isDev ? DepType.dev : DepType.prod,
            dependencies: {},
            name: dep.$.Include,
            // Version could be in attributes or as child node.
            version,
        };
        if (targetFrameworks.length) {
            depSubTree.targetFrameworks = targetFrameworks;
        }
        return depSubTree;
    }
    else {
        return { name: dep.$.Include, withoutVersion: true };
    }
}
function extractDependencyVersion(dep, manifestFile, propsMap) {
    const VARS_MATCHER = /^\$\((.*?)\)/;
    let version = _.get(dep, '$.Version') || _.get(dep, 'Version');
    if (Array.isArray(version)) {
        version = version[0];
    }
    const variableVersion = version && version.match(VARS_MATCHER);
    if (!variableVersion) {
        return version;
    }
    // version is a variable, extract it from manifest or props lookup
    const propertyName = variableVersion[1];
    const propertyMap = Object.assign(Object.assign({}, propsMap), getPropertiesMap(manifestFile));
    return _.get(propertyMap, propertyName, null);
}
function getConditionalFrameworks(condition) {
    const regexp = /\(TargetFramework\)'\s?==\s? '((\w|\d|\.)*)'/g;
    const frameworks = [];
    let match = regexp.exec(condition);
    while (match !== null) {
        frameworks.push(match[1]);
        match = regexp.exec(condition);
    }
    return frameworks;
}
function parseXmlFile(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            parseXML
                .parseString(manifestFileContents, (err, result) => {
                if (err) {
                    const e = new errors_1.InvalidUserInputError('xml file parsing failed');
                    return reject(e);
                }
                return resolve(result);
            });
        });
    });
}
exports.parseXmlFile = parseXmlFile;
function getPropertiesMap(propsContents) {
    const projectPropertyGroup = _.get(propsContents, 'Project.PropertyGroup', []);
    const props = {};
    if (!projectPropertyGroup.length) {
        return props;
    }
    for (const group of projectPropertyGroup) {
        for (const key of Object.keys(group)) {
            _.set(props, key, group[key][0]);
        }
    }
    return props;
}
exports.getPropertiesMap = getPropertiesMap;
function getTargetFrameworksFromProjectFile(manifestFile) {
    let targetFrameworksResult = [];
    const projectPropertyGroup = _.get(manifestFile, 'Project.PropertyGroup', []);
    if (!projectPropertyGroup) {
        return targetFrameworksResult;
    }
    const propertyList = projectPropertyGroup
        .find((propertyGroup) => {
        return _.has(propertyGroup, 'TargetFramework')
            || _.has(propertyGroup, 'TargetFrameworks')
            || _.has(propertyGroup, 'TargetFrameworkVersion');
    }) || {};
    if (_.isEmpty(propertyList)) {
        return targetFrameworksResult;
    }
    // TargetFrameworks is expected to be a list ; separated
    if (propertyList.TargetFrameworks) {
        for (const item of propertyList.TargetFrameworks) {
            targetFrameworksResult = [...targetFrameworksResult, ...item.split(';')];
        }
    }
    // TargetFrameworkVersion is expected to be a string containing only one item
    // TargetFrameworkVersion also implies .NETFramework, for convenience
    // return longer version
    if (propertyList.TargetFrameworkVersion) {
        targetFrameworksResult.push(`.NETFramework,Version=${propertyList.TargetFrameworkVersion[0]}`);
    }
    // TargetFrameworks is expected to be a string
    if (propertyList.TargetFramework) {
        targetFrameworksResult = [...targetFrameworksResult, ...propertyList.TargetFramework];
    }
    return _.uniq(targetFrameworksResult);
}
exports.getTargetFrameworksFromProjectFile = getTargetFrameworksFromProjectFile;
function getTargetFrameworksFromProjectConfig(manifestFile) {
    const targetFrameworksResult = [];
    const packages = _.get(manifestFile, 'packages.package', []);
    for (const item of packages) {
        const targetFramework = item.$.targetFramework;
        if (!targetFramework) {
            continue;
        }
        if (!_.includes(targetFrameworksResult, targetFramework)) {
            targetFrameworksResult.push(targetFramework);
        }
    }
    return targetFrameworksResult;
}
exports.getTargetFrameworksFromProjectConfig = getTargetFrameworksFromProjectConfig;
function getTargetFrameworksFromProjectJson(manifestFile) {
    return Object.keys(_.get(manifestFile, 'frameworks', {}));
}
exports.getTargetFrameworksFromProjectJson = getTargetFrameworksFromProjectJson;
function getTargetFrameworksFromProjectAssetsJson(manifestFile) {
    return Object.keys(_.get(manifestFile, 'targets', {}));
}
exports.getTargetFrameworksFromProjectAssetsJson = getTargetFrameworksFromProjectAssetsJson;
//# sourceMappingURL=index.js.map