"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("source-map-support/register");
const fs = require("fs");
const path = require("path");
const _ = require("lodash");
const parsers_1 = require("./parsers");
exports.DepType = parsers_1.DepType;
const project_assets_json_parser_1 = require("./parsers/project-assets-json-parser");
const errors_1 = require("./errors");
const PROJ_FILE_EXTENSIONS = [
    '.csproj',
    '.vbproj',
    '.fsproj',
];
function buildDepTreeFromProjectJson(manifestFileContents, includeDev = false) {
    // trimming required to address files with UTF-8 with BOM encoding
    const manifestFile = JSON.parse(manifestFileContents.trim());
    return parsers_1.getDependencyTreeFromProjectJson(manifestFile, includeDev);
}
exports.buildDepTreeFromProjectJson = buildDepTreeFromProjectJson;
// TODO: Figure out what to do about devDeps
function buildDepTreeFromProjectAssetsJson(manifestFileContents, targetFramework) {
    if (!targetFramework) {
        throw new Error('Missing targetFramework for project.assets.json');
    }
    // trimming required to address files with UTF-8 with BOM encoding
    const manifestFile = JSON.parse(manifestFileContents.trim());
    return project_assets_json_parser_1.getDependencyTreeFromProjectAssetsJson(manifestFile, targetFramework);
}
exports.buildDepTreeFromProjectAssetsJson = buildDepTreeFromProjectAssetsJson;
function buildDepTreeFromPackagesConfig(manifestFileContents, includeDev = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const manifestFile = yield parsers_1.parseXmlFile(manifestFileContents);
        return parsers_1.getDependencyTreeFromPackagesConfig(manifestFile, includeDev);
    });
}
exports.buildDepTreeFromPackagesConfig = buildDepTreeFromPackagesConfig;
function buildDepTreeFromProjectFile(manifestFileContents, includeDev = false, propsMap = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const manifestFile = yield parsers_1.parseXmlFile(manifestFileContents);
        return parsers_1.getDependencyTreeFromProjectFile(manifestFile, includeDev, propsMap);
    });
}
exports.buildDepTreeFromProjectFile = buildDepTreeFromProjectFile;
function buildDepTreeFromFiles(root, manifestFilePath, includeDev = false, targetFramework) {
    if (!root || !manifestFilePath) {
        throw new Error('Missing required parameters for buildDepTreeFromFiles()');
    }
    const manifestFileFullPath = path.resolve(root, manifestFilePath);
    if (!fs.existsSync(manifestFileFullPath)) {
        throw new Error('No packages.config, project.json or project file found at ' +
            `location: ${manifestFileFullPath}`);
    }
    const manifestFileContents = fs.readFileSync(manifestFileFullPath, 'utf-8');
    const manifestFileExtension = path.extname(manifestFileFullPath);
    if (_.includes(PROJ_FILE_EXTENSIONS, manifestFileExtension)) {
        return buildDepTreeFromProjectFile(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'packages.config')) {
        return buildDepTreeFromPackagesConfig(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'project.json')) {
        return buildDepTreeFromProjectJson(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'project.assets.json')) {
        return buildDepTreeFromProjectAssetsJson(manifestFileContents, targetFramework);
    }
    else {
        throw new Error(`Unsupported file ${manifestFilePath}, Please provide ` +
            'either packages.config or project file.');
    }
}
exports.buildDepTreeFromFiles = buildDepTreeFromFiles;
function extractTargetFrameworksFromFiles(root, manifestFilePath, includeDev = false) {
    if (!root || !manifestFilePath) {
        throw new Error('Missing required parameters for extractTargetFrameworksFromFiles()');
    }
    const manifestFileFullPath = path.resolve(root, manifestFilePath);
    if (!fs.existsSync(manifestFileFullPath)) {
        throw new Error('No project file found at ' +
            `location: ${manifestFileFullPath}`);
    }
    const manifestFileContents = fs.readFileSync(manifestFileFullPath, 'utf-8');
    const manifestFileExtension = path.extname(manifestFileFullPath);
    if (_.includes(PROJ_FILE_EXTENSIONS, manifestFileExtension)) {
        return extractTargetFrameworksFromProjectFile(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'packages.config')) {
        return extractTargetFrameworksFromProjectConfig(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'project.json')) {
        return extractTargetFrameworksFromProjectJson(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'project.assets.json')) {
        return extractTargetFrameworksFromProjectAssetsJson(manifestFileContents);
    }
    else {
        throw new Error(`Unsupported file ${manifestFilePath}, Please provide ` +
            'a project *.csproj, *.vbproj, *.fsproj or packages.config file.');
    }
}
exports.extractTargetFrameworksFromFiles = extractTargetFrameworksFromFiles;
function extractTargetFrameworksFromProjectFile(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const manifestFile = yield parsers_1.parseXmlFile(manifestFileContents);
            return parsers_1.getTargetFrameworksFromProjectFile(manifestFile);
        }
        catch (err) {
            throw new Error(`Extracting target framework failed with error ${err.message}`);
        }
    });
}
exports.extractTargetFrameworksFromProjectFile = extractTargetFrameworksFromProjectFile;
function extractTargetFrameworksFromProjectConfig(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const manifestFile = yield parsers_1.parseXmlFile(manifestFileContents);
            return parsers_1.getTargetFrameworksFromProjectConfig(manifestFile);
        }
        catch (err) {
            throw new Error(`Extracting target framework failed with error ${err.message}`);
        }
    });
}
exports.extractTargetFrameworksFromProjectConfig = extractTargetFrameworksFromProjectConfig;
function containsPackageReference(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const manifestFile = yield parsers_1.parseXmlFile(manifestFileContents);
        const projectItems = _.get(manifestFile, 'Project.ItemGroup', []);
        const referenceIndex = _.findIndex(projectItems, (itemGroup) => _.has(itemGroup, 'PackageReference'));
        return referenceIndex !== -1;
    });
}
exports.containsPackageReference = containsPackageReference;
function extractTargetFrameworksFromProjectJson(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // trimming required to address files with UTF-8 with BOM encoding
            const manifestFile = JSON.parse(manifestFileContents.trim());
            return parsers_1.getTargetFrameworksFromProjectJson(manifestFile);
        }
        catch (err) {
            throw new Error(`Extracting target framework failed with error ${err.message}`);
        }
    });
}
exports.extractTargetFrameworksFromProjectJson = extractTargetFrameworksFromProjectJson;
function extractTargetFrameworksFromProjectAssetsJson(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // trimming required to address files with UTF-8 with BOM encoding
            const manifestFile = JSON.parse(manifestFileContents.trim());
            return parsers_1.getTargetFrameworksFromProjectAssetsJson(manifestFile);
        }
        catch (err) {
            throw new Error(`Extracting target framework failed with error ${err.message}`);
        }
    });
}
exports.extractTargetFrameworksFromProjectAssetsJson = extractTargetFrameworksFromProjectAssetsJson;
function extractProps(propsFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const propsFile = yield parsers_1.parseXmlFile(propsFileContents);
            if (!propsFile) {
                throw new errors_1.InvalidUserInputError('xml file parsing failed');
            }
            return parsers_1.getPropertiesMap(propsFile);
        }
        catch (err) {
            if (err.name === 'InvalidUserInputError') {
                throw err;
            }
            throw new Error(`Extracting props failed with error ${err.message}`);
        }
    });
}
exports.extractProps = extractProps;
//# sourceMappingURL=index.js.map