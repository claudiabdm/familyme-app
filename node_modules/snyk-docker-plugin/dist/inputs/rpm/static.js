"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const extractor_1 = require("../../extractor");
const stream_utils_1 = require("../../stream-utils");
const sub_process_1 = require("../../sub-process");
exports.getRpmDbFileContentAction = {
    actionName: "rpm-db",
    fileNamePattern: "/var/lib/rpm/Packages",
    callback: stream_utils_1.streamToBuffer,
};
function getRpmDbFileContent(extractedLayers, tmpDirPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const apkDb = extractor_1.getContentAsBuffer(extractedLayers, exports.getRpmDbFileContentAction);
        if (!apkDb) {
            return "";
        }
        const filePath = generateTempFileName(tmpDirPath);
        yield writeToFile(filePath, apkDb);
        try {
            // This is the tool that is expected to be found on the system:
            // https://github.com/snyk/go-rpmdb
            const cmdOutput = yield sub_process_1.execute("rpmdb", ["-f", filePath]).catch(handleError);
            return cmdOutput.stdout || "";
        }
        finally {
            yield removeFile(filePath);
        }
    });
}
exports.getRpmDbFileContent = getRpmDbFileContent;
function handleError(error) {
    const stderr = error.stderr;
    if (typeof stderr === "string" && stderr.indexOf("not found") >= 0) {
        return { stdout: "", stderr: "" };
    }
    throw error;
}
/**
 * Exported for testing
 */
function generateTempFileName(tmpDirPath) {
    const tmpPath = tmpDirPath || os_1.tmpdir();
    const randomFileName = Math.random().toString();
    return path_1.resolve(tmpPath, randomFileName);
}
exports.generateTempFileName = generateTempFileName;
function writeToFile(filePath, apkDb) {
    return new Promise((resolve, reject) => {
        fs_1.writeFile(filePath, apkDb, { encoding: "binary" }, (err) => {
            if (!err) {
                resolve();
            }
            else {
                reject(err);
            }
        });
    });
}
function removeFile(filePath) {
    return new Promise((resolve) => {
        fs_1.unlink(filePath, () => {
            resolve();
        });
    });
}
//# sourceMappingURL=static.js.map