"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const minimatch = require("minimatch");
const path_1 = require("path");
const tar_stream_1 = require("tar-stream");
const stream_utils_1 = require("../stream-utils");
const callbacks_1 = require("./callbacks");
/**
 * Retrieve the products of files content from the specified docker-archive.
 * @param dockerArchiveFilesystemPath Path to image file saved in docker-archive format.
 * @param extractActions Array of pattern-callbacks pairs.
 * @returns Array of extracted files products sorted by the reverse order of the layers from last to first.
 */
function extractDockerArchive(dockerArchiveFilesystemPath, extractActions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const tarExtractor = tar_stream_1.extract();
            const layers = {};
            let manifest;
            tarExtractor.on("entry", (header, stream, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (header.type === "file") {
                    if (isTarFile(header.name)) {
                        layers[header.name] = yield extractImageLayer(stream, extractActions);
                    }
                    else if (isManifestFile(header.name)) {
                        manifest = yield getManifestFile(stream);
                    }
                }
                stream.resume(); // auto drain the stream
                next(); // ready for next entry
            }));
            tarExtractor.on("finish", () => {
                resolve(getLayersContentAndArchiveManifest(manifest, layers));
            });
            tarExtractor.on("error", (error) => reject(error));
            fs_1.createReadStream(dockerArchiveFilesystemPath).pipe(tarExtractor);
        });
    });
}
exports.extractDockerArchive = extractDockerArchive;
/**
 * Extract key files from the specified TAR stream.
 * @param layerTarStream image layer as a Readable TAR stream. Note: consumes the stream.
 * @param extractActions array of pattern, callbacks pairs
 * @returns extracted file products
 */
function extractImageLayer(layerTarStream, extractActions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const result = {};
            const tarExtractor = tar_stream_1.extract();
            tarExtractor.on("entry", (headers, stream, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (headers.type === "file") {
                    const absoluteFileName = path_1.resolve("/", headers.name);
                    const processedResult = yield extractFileAndProcess(absoluteFileName, stream, extractActions);
                    if (processedResult !== undefined) {
                        result[absoluteFileName] = processedResult;
                    }
                }
                stream.resume(); // auto drain the stream
                next(); // ready for next entry
            }));
            tarExtractor.on("finish", () => {
                // all layer level entries read
                resolve(result);
            });
            tarExtractor.on("error", (error) => reject(error));
            layerTarStream.pipe(tarExtractor);
        });
    });
}
exports.extractImageLayer = extractImageLayer;
/**
 * Note: consumes the stream.
 */
function extractFileAndProcess(fileName, fileStream, extractActions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const matchedActions = extractActions.filter((action) => minimatch(fileName, action.fileNamePattern, { dot: true }));
        if (matchedActions.length > 0) {
            return yield callbacks_1.applyCallbacks(matchedActions, fileStream);
        }
        return undefined;
    });
}
function getLayersContentAndArchiveManifest(manifest, layers) {
    // skip (ignore) non-existent layers
    // get the layers content without the name
    // reverse layers order from last to first
    const filteredLayers = manifest.Layers.filter((layersName) => layers[layersName])
        .map((layerName) => layers[layerName])
        .reverse();
    return {
        layers: filteredLayers,
        manifest,
    };
}
/**
 * Note: consumes the stream.
 */
function getManifestFile(stream) {
    return stream_utils_1.streamToString(stream).then((manifestFile) => {
        const manifest = JSON.parse(manifestFile);
        return manifest[0];
    });
}
function isManifestFile(name) {
    return name === "manifest.json";
}
function isTarFile(name) {
    // For both "docker save" and "skopeo copy" style archives the
    // layers are represented as tar archives whose names end in .tar.
    // For Docker this is "layer.tar", for Skopeo - "<sha256ofLayer>.tar".
    return path_1.basename(name).endsWith(".tar");
}
//# sourceMappingURL=layer.js.map