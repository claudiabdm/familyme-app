"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var types_1 = require("../types");
var ComposerParser = /** @class */ (function () {
    function ComposerParser() {
    }
    ComposerParser.getVersion = function (depObj) {
        // check for `version` property. may not exist
        var versionFound = _.get(depObj, 'version', '');
        // even if found, may be an alias, so check
        var availableAliases = _.get(depObj, "extra['branch-alias']", []);
        // if the version matches the alias (either as is, or without 'dev-'), use the aliases version.
        // otherwise, use the version as is, and if not, the first found alias
        return _.get(availableAliases, versionFound) ||
            _.get(_.invert(availableAliases), versionFound.replace('dev-', '')) &&
                versionFound.replace('dev-', '') ||
            versionFound ||
            _.findKey(_.invert(availableAliases), '0'); // first available alias
    };
    ComposerParser.buildDependencies = function (composerJsonObj, composerLockObj, depObj, systemPackages, includeDev, isDevTree, depRecursiveArray, packageRefCount) {
        if (includeDev === void 0) { includeDev = false; }
        if (isDevTree === void 0) { isDevTree = false; }
        if (depRecursiveArray === void 0) { depRecursiveArray = []; }
        if (packageRefCount === void 0) { packageRefCount = {}; }
        var result = {};
        // find depObj properties
        var depName = _.get(depObj, 'name');
        var require = _.get(depObj, 'require', {});
        var requireDev = includeDev ? _.get(depObj, 'require-dev', {}) : {};
        // recursion tests
        var inRecursiveArray = depRecursiveArray.indexOf(depName) > -1;
        var exceedsMaxRepeats = packageRefCount[depName] >= this.MAX_PACKAGE_REPEATS;
        var hasNoDependencies = _.isEmpty(require) && _.isEmpty(requireDev);
        // break recursion when
        if (inRecursiveArray || exceedsMaxRepeats || hasNoDependencies) {
            return result;
        }
        // prevent circular dependencies
        depRecursiveArray.push(depName);
        // get locked packages
        var packages = _.get(composerLockObj, 'packages', []);
        var packagesDev = includeDev ? _.get(composerLockObj, 'packages-dev', []) : [];
        var allPackages = packages.concat(packagesDev);
        var _loop_1 = function (name_1) {
            var version = '';
            // lets find if this dependency has an object in composer.lock
            var lockedPackage = allPackages.find(function (dep) { return dep.name === name_1; });
            if (lockedPackage) {
                version = this_1.getVersion(lockedPackage);
            }
            else {
                // here we use the system version or composer json - not a locked version
                version = _.get(systemPackages, name_1) || _.get(require, name_1);
            }
            // remove any starting 'v' from version numbers
            version = version.replace(/^v(\d)/, '$1');
            // bump package reference count (or assign to 1 if we haven't seen this before)
            packageRefCount[name_1] = (packageRefCount[name_1] || 0) + 1;
            result[name_1] = {
                name: name_1,
                version: version,
                dependencies: this_1.buildDependencies(composerJsonObj, composerLockObj, lockedPackage, // undefined if transitive dependency
                systemPackages, includeDev, false, depRecursiveArray, packageRefCount),
                labels: {
                    scope: isDevTree ? types_1.Scope.dev : types_1.Scope.prod,
                },
            };
        };
        var this_1 = this;
        // parse require dependencies
        for (var _i = 0, _a = Object.keys(require); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            _loop_1(name_1);
        }
        var _loop_2 = function (name_2) {
            var version = '';
            // lets find if this dependency has an object in composer.lock
            var lockedPackage = allPackages.find(function (dep) { return dep.name === name_2; });
            if (lockedPackage) {
                version = this_2.getVersion(lockedPackage);
            }
            else {
                // here we use the system version or composer json - not a locked version
                version = _.get(systemPackages, name_2) || _.get(requireDev, name_2);
            }
            // remove any starting 'v' from version numbers
            version = version.replace(/^v(\d)/, '$1');
            // bump package reference count (or assign to 1 if we haven't seen this before)
            packageRefCount[name_2] = (packageRefCount[name_2] || 0) + 1;
            result[name_2] = {
                name: name_2,
                version: version,
                dependencies: this_2.buildDependencies(composerJsonObj, composerLockObj, lockedPackage, // undefined if transitive dependency
                systemPackages, includeDev, true, depRecursiveArray, packageRefCount),
                labels: {
                    scope: types_1.Scope.dev,
                },
            };
        };
        var this_2 = this;
        // parse require-dev dependencies
        for (var _b = 0, _c = Object.keys(requireDev); _b < _c.length; _b++) {
            var name_2 = _c[_b];
            _loop_2(name_2);
        }
        // remove from recursive check
        depRecursiveArray.pop();
        // return dep tree
        return result;
    };
    // After this threshold, a package node in the dep tree won't have expanded dependencies.
    // This is a cheap protection against combinatorial explosion when there's N packages
    // that depend on each other (producing N! branches of the dep tree).
    // The value of 150 was chosen as a lowest one that doesn't break existing tests.
    // Switching to dependency graph would render this trick obsolete.
    ComposerParser.MAX_PACKAGE_REPEATS = 150;
    return ComposerParser;
}());
exports.ComposerParser = ComposerParser;
//# sourceMappingURL=composer-parser.js.map